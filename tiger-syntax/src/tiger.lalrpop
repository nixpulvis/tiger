use std::str::FromStr;
use ast::*;
use tok::{self, Tok};

grammar<'input>(text: &'input str)["LALR(1)"];

// Macros
/////////

List<T, D>: Vec<T> = {
    <v:(<T> D)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Repeat<T>: Vec<T> = {
    <v:(<T>)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

// Symbol
/////////

Symbol: Symbol = {
    "SYMBOL" => <>.into()
};

// Expression
/////////////

pub Expression: Box<Expression> = {
    NilExp       => <>,
    BreakExp     => <>,
    IntExp       => <>,
    StringExp    => <>,
    VariableExp  => <>,
    IfExp        => <>,
    SequenceExp  => <>,
    CallExp      => <>,
    OperationExp => <>,
    RecordExp    => <>,
    AssignExp    => <>,
    WhileExp     => <>,
    ForExp       => <>,
    LetExp       => <>,
    // ArrayExp     => <>,
    NegationExp  => <>,
    AndExp       => <>,
    OrExp        => <>,
};

NilExp: Box<Expression> = {
    "NIL" => Box::new(Expression::Nil)
};

BreakExp: Box<Expression> = {
    "BREAK" => Box::new(Expression::Break)
};

IntExp: Box<Expression> = {
    // r"[0-9]+" => Box::new(Expression::Int(i32::from_str(<>).unwrap())),
    "INT" => Box::new(Expression::Int(i32::from_str(<>).unwrap())),
};

// TODO: This is clearly wrong.
StringExp: Box<Expression> = {
    // r#"".*""# => Box::new(Expression::String(<>.into()))
    "STRING" => Box::new(Expression::String(<>.into()))
};

VariableExp: Box<Expression> = {
    Variable => Box::new(Expression::Variable(<>))
};

// FIXME: Add if then else
IfExp: Box<Expression> = {
    "IF" <test:Expression> "THEN" <t:Expression> => Box::new(Expression::If {
        test: test,
        t: t,
        f: None,
    }),
    // "if" <test:Expression> "then" <t:Expression> "else" <f:Expression> =>
    //     Expression::If(Box::new(test), Box::new(t), Some(Box::new(f))),
};

SequenceExp: Box<Expression> = {
    "LPAREN" <l:List<Expression, "SEMI">> "RPAREN" => Box::new(Expression::Sequence(l))
};

CallExp: Box<Expression> = {
    <s:Symbol> "LPAREN" <l:List<Expression, "COMMA">> "RPAREN" => Box::new(Expression::Call {
        ident: s,
        arguments: l,
    })
};

// FIXME: Remove parens.
OperationExp: Box<Expression> = {
    "LPAREN" <l:Expression> <o:Operation> <r:Expression> "RPAREN" => Box::new(Expression::Operation {
        op: o,
        left: l,
        right: r,
    })
};

RecordExp: Box<Expression> = {
    <s:Symbol> "LBRACE" <l:List<field_create, "COMMA">> "RBRACE" => Box::new(Expression::Record {
        fields: l,
        tdent: s,
    })
};

field_create: (Symbol, Box<Expression>) = {
    <s:Symbol> "EQ" <e:Expression> => (s, e)
};

AssignExp: Box<Expression> = {
    <v:Variable> "ASSIGN" <e:Expression> => Box::new(Expression::Assign {
        variable: v,
        expression: e,
    })
};

WhileExp: Box<Expression> = {
    "WHILE" <t:Expression> "DO" <b:Expression> => Box::new(Expression::While {
        test: t,
        body: b,
    })
};

ForExp: Box<Expression> = {
    "FOR" <s:Symbol> "ASSIGN" <l:Expression> "TO" <h:Expression> "DO" <b:Expression> => {
        Box::new(Expression::For {
            ident: s,
            low: l,
            high: h,
            body: b,
        })
    }
};

LetExp: Box<Expression> = {
    "LET" <d:Repeat<Declaration>> "IN" <e:Expression> "END" => {
        Box::new(Expression::Let {
            declarations: d,
            body: e,
        })
    }
};

// FIXME: Don't use $ symbols.
ArrayExp: Box<Expression> = {
    <s:Symbol> "HASH" <l:Expression> "HASH" "OF" <i:Expression> => Box::new(Expression::Array {
        tdent: s,
        size: l,
        init: i,
    })
};

NegationExp: Box<Expression> = {
    "MINUS" <e:Expression> => Box::new(Expression::Operation {
        op: Operation::Minus,
        left: Box::new(Expression::Int(0)),
        right: e,
    })
};

// FIXME: Don't wrap in parens
AndExp: Box<Expression> = {
    "LPAREN" <e1:Expression> "AND" <e2:Expression> "RPAREN" => Box::new(Expression::If {
        test: e1,
        t: e2,
        f: Some(Box::new(Expression::Int(0))),
    })
};

// FIXME: Don't wrap in parens
OrExp: Box<Expression> = {
    "LPAREN" <e1:Expression> "OR" <e2:Expression> "RPAREN" => Box::new(Expression::If {
        test: e1,
        t: Box::new(Expression::Int(1)),
        f: Some(e2),
    })
};

// Operation
////////////

Operation: Operation = {
    "PLUS"   => Operation::Plus,
    "MINUS"  => Operation::Minus,
    "TIMES"  => Operation::Times,
    "DIVIDE" => Operation::Divide,
    "EQ"     => Operation::Eq,
    "NEQ"    => Operation::Neq,
    "LT"     => Operation::Lt,
    "LE"     => Operation::Le,
    "GT"     => Operation::Gt,
    "GE"     => Operation::Ge,
};

// Variable
///////////

Variable: Box<Variable> = {
    Symbol => Box::new(Variable::Simple(<>)),
    <v:Variable> "DOT" <s:Symbol> => Box::new(Variable::Field(v, s)),
    <v:Variable> "LBRACK" <e:Expression> "RBRACK" => Box::new(Variable::Subscript(v, e))
};

// Type
///////

Type: Box<Type> = {
    <s:Symbol> => Box::new(Type::Name(s)),
    "LBRACE" <l:List<field_dec, "COMMA">> "RBRACE" => Box::new(Type::Record(l)),
    "ARRAY" "OF" <s:Symbol> => Box::new(Type::Array(s)),
};

field_dec: (Symbol, Symbol) = {
    <i:Symbol> "COLON" <t:Symbol> => (i, t)
};

// Declaration
//////////////

Declaration: Box<Declaration> = {
	FunctionDec => <>,
	VariableDec => <>,
	TypeDec => <>,
};

FunctionDec: Box<Declaration> = {
    "FUNCTION" <s:Symbol> "LPAREN" <l:List<field_dec, "COMMA">> "RPAREN" "EQ" <e:Expression> => {
        Box::new(Declaration::Function {
            ident: s,
            parameters: l,
            result: None,
            body: e,
        })
    },
    "FUNCTION" <s:Symbol> "LPAREN" <l:List<field_dec, "COMMA">> "RPAREN" "COLON" <t:Symbol> "EQ" <e:Expression> => {
        Box::new(Declaration::Function {
            ident: s,
            parameters: l,
            result: Some(t),
            body: e,
        })
    },
};

VariableDec: Box<Declaration> = {
    "VAR" <s:Symbol> "ASSIGN" <e:Expression> => Box::new(Declaration::Variable {
        ident: s,
        tdent: None,
        init: e,
    }),
    "VAR" <s:Symbol> "COLON" <t:Symbol> "ASSIGN" <e:Expression> => Box::new(Declaration::Variable {
        ident: s,
        tdent: Some(t),
        init: e,
    }),
};

TypeDec: Box<Declaration> = {
    "TYPE" <s:Symbol> "EQ" <t:Type> => Box::new(Declaration::Type {
        tdent: s,
        ty: t,
    })
};

// Tokens
/////////

extern {
    type Location = usize;
    type Error = tok::Error;

    enum Tok<'input> {
        "SYMBOL" => Tok::Symbol(<&'input str>),
        "INT" => Tok::Int(<&'input str>),
        "STRING" => Tok::String(<&'input str>),

        "NIL" => Tok::Nil,
        "BREAK" => Tok::Break,
        "IF" => Tok::If,
        "THEN" => Tok::Then,
        "ELSE" => Tok::Else,
        "TYPE" => Tok::Type,
        "FUNCTION" => Tok::Function,
        "VAR" => Tok::Var,
        "ASSIGN" => Tok::Assign,
        "WHILE" => Tok::While,
        "FOR" => Tok::For,
        "TO" => Tok::To,
        "DO" => Tok::Do,
        "LET" => Tok::Let,
        "IN" => Tok::In,
        "END" => Tok::End,
        "HASH" => Tok::Hash,  // TODO: This is a hack for now.
        "ARRAY" => Tok::Array,
        "OF" => Tok::Of,
        "COLON" => Tok::Colon,
        "SEMI" => Tok::Semi,
        "COMMA" => Tok::Comma,
        "LPAREN" => Tok::LParen,
        "RPAREN" => Tok::RParen,
        "LBRACK" => Tok::LBrack,
        "RBRACK" => Tok::RBrack,
        "LBRACE" => Tok::LBrace,
        "RBRACE" => Tok::RBrace,
        "DOT" => Tok::Dot,
        "EQ" => Tok::Eq,
        "NEQ" => Tok::Neq,
        "AND" => Tok::And,
        "OR" => Tok::Or,
        "PLUS" => Tok::Plus,
        "MINUS" => Tok::Minus,
        "TIMES" => Tok::Times,
        "DIVIDE" => Tok::Divide,
        "LT" => Tok::Lt,
        "LE" => Tok::Le,
        "GT" => Tok::Gt,
        "GE" => Tok::Ge,
    }
}
